## 프록시 패턴과 데코레이터 패턴

### 시작전 더 나은 이해를 위한 설정
- 인터페이스 구현 클래스 -> 스프링 빈 수동등록
- 인터페이스 없는 클래스 -> 스프링 빈 수동등록
- ComponentScan으로 스프링 빈 자동등록

### 프록시 패턴과 데코레이터 패턴의 차이
- 프록시 패턴 : 접근 제어가 목적 (프록시 패턴 != 프록시)
  - 권한에 따라 접근을 차단 할 수 있다.
  - 캐싱 역할이 가능하다.
  - 지연 로딩을 한다.

- 데코레이터 패턴 : 부가 기능 추가가 목적
  - 원래 서버가 제공하는 기능에 더해서 부가 기능을 수행한다.
  - ex) 로깅

### 인터페이스 기반 프록시와 클래스 기반 프록시

#### 공통점
- 다형성을 적용해서 사용
- 기존 코드(비지니스 로직)를 바꾸지 않고, 부가기능을 추가 가능
- 프록시 클래스를 추가함

#### 차이점
- 클래스 기반 프록시
  - 해당 클래스에서만 적용 가능
  - 부모 클래스의 생성자를 호출해야함(super() 를 통해서)
  - 클래스에 final 붙는다면 상속이 불가능해짐 -> 다형성에 제약
  - 메서드에 final 붙는다면 override 불가능해짐 -> 다형성에 제약

- 인터페이스 기반 프록시
  - 인터페이스만 같다면 모든 곳에 적용 가능 -> 확장에 용이
  - 다만, 인터페이스가 꼭 필요하다. -> 인터페이스가 없으면 애초에 불가
  - 인터페이스가 장점이 많지만, 항상 필요한 것은 아님

### 리플랙션
- 장점 : 클래스와 메서드의 메타정보를 활용해서 애플리케이션을 동적으로 유연하게 사용할 수 있다.
- 단점 : 런타임에 동작한다. -> 컴파일 시점에서 오류를 잡지 못함


### AOP
- pointcut : 필터 역할(적용할 대상을 확인)
- advice : 추가 적용할 로직(부가기능으로 추가할 로직 적용)
- advisor : 하나의 pointcut + 하나의 advise
- proxy에 무조건 advisor 있어야 함
  - 하나의 proxy에 둘 이상의 advisor 가능
  - 여러 advisor가 존재한다 하더라도 여러 proxy가 존재하는 것은 아님
- 탐색 순서
  - 클라이언트 요청 -> 프록시(팩토리) -> pointcut으로 먼저 필터링 -> 적용 대상이면 advice 로직 실행 -> target(비지니스 로직)실행
  - 클라이언트 요청 -> 프록시(팩토리) -> pointcut으로 먼저 필터링 -> 적용 대상이 아님 advice 로직 실행 안함 -> target(비지니스 로직)실행

### 제목